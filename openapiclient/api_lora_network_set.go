/*
SORACOM API

SORACOM API v1

API version: VERSION_PLACEHOLDER
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapiclient

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// LoraNetworkSetApiService LoraNetworkSetApi service
type LoraNetworkSetApiService service

type ApiAddPermissionToLoraNetworkSetRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
	updatePermissionRequest *UpdatePermissionRequest
}

// 許可された Operator のリストに追加すべき Operator の ID
func (r ApiAddPermissionToLoraNetworkSetRequest) UpdatePermissionRequest(updatePermissionRequest UpdatePermissionRequest) ApiAddPermissionToLoraNetworkSetRequest {
	r.updatePermissionRequest = &updatePermissionRequest
	return r
}

func (r ApiAddPermissionToLoraNetworkSetRequest) Execute() (*LoraNetworkSet, *http.Response, error) {
	return r.ApiService.AddPermissionToLoraNetworkSetExecute(r)
}

/*
AddPermissionToLoraNetworkSet Adds permission to a LoRa network set.

別の Operator から Network Set が利用できるようにパーミッションを追加する。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId 対象の LoRa network set の ID
 @return ApiAddPermissionToLoraNetworkSetRequest
*/
func (a *LoraNetworkSetApiService) AddPermissionToLoraNetworkSet(ctx context.Context, nsId string) ApiAddPermissionToLoraNetworkSetRequest {
	return ApiAddPermissionToLoraNetworkSetRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
	}
}

// Execute executes the request
//  @return LoraNetworkSet
func (a *LoraNetworkSetApiService) AddPermissionToLoraNetworkSetExecute(r ApiAddPermissionToLoraNetworkSetRequest) (*LoraNetworkSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LoraNetworkSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.AddPermissionToLoraNetworkSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}/add_permission"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePermissionRequest == nil {
		return localVarReturnValue, nil, reportError("updatePermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateLoraNetworkSetRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	loraNetworkSet *LoraNetworkSet
}

// タグなど作成対象の LoRa network set に設定する付加情報
func (r ApiCreateLoraNetworkSetRequest) LoraNetworkSet(loraNetworkSet LoraNetworkSet) ApiCreateLoraNetworkSetRequest {
	r.loraNetworkSet = &loraNetworkSet
	return r
}

func (r ApiCreateLoraNetworkSetRequest) Execute() (*LoraNetworkSet, *http.Response, error) {
	return r.ApiService.CreateLoraNetworkSetExecute(r)
}

/*
CreateLoraNetworkSet Creates a LoRa network set

LoRa network set を作成する

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateLoraNetworkSetRequest
*/
func (a *LoraNetworkSetApiService) CreateLoraNetworkSet(ctx context.Context) ApiCreateLoraNetworkSetRequest {
	return ApiCreateLoraNetworkSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LoraNetworkSet
func (a *LoraNetworkSetApiService) CreateLoraNetworkSetExecute(r ApiCreateLoraNetworkSetRequest) (*LoraNetworkSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LoraNetworkSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.CreateLoraNetworkSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.loraNetworkSet == nil {
		return localVarReturnValue, nil, reportError("loraNetworkSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.loraNetworkSet
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteLoraNetworkSetRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
}

func (r ApiDeleteLoraNetworkSetRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLoraNetworkSetExecute(r)
}

/*
DeleteLoraNetworkSet Delete LoRa network set.

指定された LoRa network set を削除する

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId 対象の LoRa network set の ID
 @return ApiDeleteLoraNetworkSetRequest
*/
func (a *LoraNetworkSetApiService) DeleteLoraNetworkSet(ctx context.Context, nsId string) ApiDeleteLoraNetworkSetRequest {
	return ApiDeleteLoraNetworkSetRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
	}
}

// Execute executes the request
func (a *LoraNetworkSetApiService) DeleteLoraNetworkSetExecute(r ApiDeleteLoraNetworkSetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.DeleteLoraNetworkSet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLoraNetworkSetTagRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
	tagName string
}

func (r ApiDeleteLoraNetworkSetTagRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLoraNetworkSetTagExecute(r)
}

/*
DeleteLoraNetworkSetTag Delete LoRa network set tag.

指定された LoRa network set のタグを削除

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId 対象の LoRa network set の ID
 @param tagName 削除対象のタグ名（URL の Path の一部になるので、パーセントエンコーディングを施す。JavaScript なら encodeURIComponent() したものを指定する）
 @return ApiDeleteLoraNetworkSetTagRequest
*/
func (a *LoraNetworkSetApiService) DeleteLoraNetworkSetTag(ctx context.Context, nsId string, tagName string) ApiDeleteLoraNetworkSetTagRequest {
	return ApiDeleteLoraNetworkSetTagRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
		tagName: tagName,
	}
}

// Execute executes the request
func (a *LoraNetworkSetApiService) DeleteLoraNetworkSetTagExecute(r ApiDeleteLoraNetworkSetTagRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.DeleteLoraNetworkSetTag")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}/tags/{tag_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tag_name"+"}", url.PathEscape(parameterToString(r.tagName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLoraNetworkSetRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
}

func (r ApiGetLoraNetworkSetRequest) Execute() (*LoraNetworkSet, *http.Response, error) {
	return r.ApiService.GetLoraNetworkSetExecute(r)
}

/*
GetLoraNetworkSet Get LoRa network set.

指定された LoRa network set の情報を返す

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId 対象の LoRa network set の ID
 @return ApiGetLoraNetworkSetRequest
*/
func (a *LoraNetworkSetApiService) GetLoraNetworkSet(ctx context.Context, nsId string) ApiGetLoraNetworkSetRequest {
	return ApiGetLoraNetworkSetRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
	}
}

// Execute executes the request
//  @return LoraNetworkSet
func (a *LoraNetworkSetApiService) GetLoraNetworkSetExecute(r ApiGetLoraNetworkSetRequest) (*LoraNetworkSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LoraNetworkSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.GetLoraNetworkSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGatewaysInLoraNetworkSetRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
	limit *int32
	lastEvaluatedKey *string
}

// 一度に取得する LoRa gateway の数の上限
func (r ApiListGatewaysInLoraNetworkSetRequest) Limit(limit int32) ApiListGatewaysInLoraNetworkSetRequest {
	r.limit = &limit
	return r
}

// 現ページで取得した最後の LoRa gateway の ID。このパラメータを指定することで次の LoRa gateway 以降のリストを取得できる。
func (r ApiListGatewaysInLoraNetworkSetRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiListGatewaysInLoraNetworkSetRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}

func (r ApiListGatewaysInLoraNetworkSetRequest) Execute() ([]LoraGateway, *http.Response, error) {
	return r.ApiService.ListGatewaysInLoraNetworkSetExecute(r)
}

/*
ListGatewaysInLoraNetworkSet List LoRa Gateways in a Network Set.

指定された Network Set に属する LoRa gateway のリストを返す。LoRa gateway の総数が 1 ページに収まらない場合は、レスポンス中に次のページにアクセスするための URL を`Link`ヘッダに含めて返す。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId 対象の LoRa network set の ID
 @return ApiListGatewaysInLoraNetworkSetRequest
*/
func (a *LoraNetworkSetApiService) ListGatewaysInLoraNetworkSet(ctx context.Context, nsId string) ApiListGatewaysInLoraNetworkSetRequest {
	return ApiListGatewaysInLoraNetworkSetRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
	}
}

// Execute executes the request
//  @return []LoraGateway
func (a *LoraNetworkSetApiService) ListGatewaysInLoraNetworkSetExecute(r ApiListGatewaysInLoraNetworkSetRequest) ([]LoraGateway, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LoraGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.ListGatewaysInLoraNetworkSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}/gateways"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListLoraNetworkSetsRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	tagName *string
	tagValue *string
	tagValueMatchMode *string
	limit *int32
	lastEvaluatedKey *string
}

// 検索対象にするタグの名前(完全一致)。
func (r ApiListLoraNetworkSetsRequest) TagName(tagName string) ApiListLoraNetworkSetsRequest {
	r.tagName = &tagName
	return r
}

// 検索対象にするタグの検索文字列。&#x60;tag_name&#x60; を指定した場合は必須。
func (r ApiListLoraNetworkSetsRequest) TagValue(tagValue string) ApiListLoraNetworkSetsRequest {
	r.tagValue = &tagValue
	return r
}

// タグの検索条件。
func (r ApiListLoraNetworkSetsRequest) TagValueMatchMode(tagValueMatchMode string) ApiListLoraNetworkSetsRequest {
	r.tagValueMatchMode = &tagValueMatchMode
	return r
}

// 一度に取得する LoRa network set の数の上限
func (r ApiListLoraNetworkSetsRequest) Limit(limit int32) ApiListLoraNetworkSetsRequest {
	r.limit = &limit
	return r
}

// 現ページで取得した最後の LoRa network set の ID。このパラメータを指定することで次以降のリストを取得できる。
func (r ApiListLoraNetworkSetsRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiListLoraNetworkSetsRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}

func (r ApiListLoraNetworkSetsRequest) Execute() ([]LoraNetworkSet, *http.Response, error) {
	return r.ApiService.ListLoraNetworkSetsExecute(r)
}

/*
ListLoraNetworkSets List LoRa Network Sets.

条件にマッチする LoRa network set のリストを返す。LoRa network set の総数が 1 ページに収まらない場合は、レスポンス中に次のページにアクセスするための URL を`Link`ヘッダに含めて返す。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListLoraNetworkSetsRequest
*/
func (a *LoraNetworkSetApiService) ListLoraNetworkSets(ctx context.Context) ApiListLoraNetworkSetsRequest {
	return ApiListLoraNetworkSetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LoraNetworkSet
func (a *LoraNetworkSetApiService) ListLoraNetworkSetsExecute(r ApiListLoraNetworkSetsRequest) ([]LoraNetworkSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LoraNetworkSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.ListLoraNetworkSets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tagName != nil {
		localVarQueryParams.Add("tag_name", parameterToString(*r.tagName, ""))
	}
	if r.tagValue != nil {
		localVarQueryParams.Add("tag_value", parameterToString(*r.tagValue, ""))
	}
	if r.tagValueMatchMode != nil {
		localVarQueryParams.Add("tag_value_match_mode", parameterToString(*r.tagValueMatchMode, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutLoraNetworkSetTagsRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
	tagUpdateRequest *[]TagUpdateRequest
}

// 追加・更新対象のタグの配列
func (r ApiPutLoraNetworkSetTagsRequest) TagUpdateRequest(tagUpdateRequest []TagUpdateRequest) ApiPutLoraNetworkSetTagsRequest {
	r.tagUpdateRequest = &tagUpdateRequest
	return r
}

func (r ApiPutLoraNetworkSetTagsRequest) Execute() (*LoraNetworkSet, *http.Response, error) {
	return r.ApiService.PutLoraNetworkSetTagsExecute(r)
}

/*
PutLoraNetworkSetTags Bulk Insert or Update LoRa network set tags.

指定された LoRa network set のタグを追加・更新

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId 対象の LoRa network set の ID
 @return ApiPutLoraNetworkSetTagsRequest
*/
func (a *LoraNetworkSetApiService) PutLoraNetworkSetTags(ctx context.Context, nsId string) ApiPutLoraNetworkSetTagsRequest {
	return ApiPutLoraNetworkSetTagsRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
	}
}

// Execute executes the request
//  @return LoraNetworkSet
func (a *LoraNetworkSetApiService) PutLoraNetworkSetTagsExecute(r ApiPutLoraNetworkSetTagsRequest) (*LoraNetworkSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LoraNetworkSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.PutLoraNetworkSetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("tagUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagUpdateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevokePermissionFromLoraNetworkSetRequest struct {
	ctx context.Context
	ApiService *LoraNetworkSetApiService
	nsId string
	updatePermissionRequest *UpdatePermissionRequest
}

// 許可された Operator のリストに追加すべき Operator の ID
func (r ApiRevokePermissionFromLoraNetworkSetRequest) UpdatePermissionRequest(updatePermissionRequest UpdatePermissionRequest) ApiRevokePermissionFromLoraNetworkSetRequest {
	r.updatePermissionRequest = &updatePermissionRequest
	return r
}

func (r ApiRevokePermissionFromLoraNetworkSetRequest) Execute() (*LoraNetworkSet, *http.Response, error) {
	return r.ApiService.RevokePermissionFromLoraNetworkSetExecute(r)
}

/*
RevokePermissionFromLoraNetworkSet Revokes a permission from a LoRa network set.

指定された LoRa network set の別の Operator への利用許可を取り消す

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nsId 対象の LoRa network set の ID
 @return ApiRevokePermissionFromLoraNetworkSetRequest
*/
func (a *LoraNetworkSetApiService) RevokePermissionFromLoraNetworkSet(ctx context.Context, nsId string) ApiRevokePermissionFromLoraNetworkSetRequest {
	return ApiRevokePermissionFromLoraNetworkSetRequest{
		ApiService: a,
		ctx: ctx,
		nsId: nsId,
	}
}

// Execute executes the request
//  @return LoraNetworkSet
func (a *LoraNetworkSetApiService) RevokePermissionFromLoraNetworkSetExecute(r ApiRevokePermissionFromLoraNetworkSetRequest) (*LoraNetworkSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LoraNetworkSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoraNetworkSetApiService.RevokePermissionFromLoraNetworkSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lora_network_sets/{ns_id}/revoke_permission"
	localVarPath = strings.Replace(localVarPath, "{"+"ns_id"+"}", url.PathEscape(parameterToString(r.nsId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePermissionRequest == nil {
		return localVarReturnValue, nil, reportError("updatePermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
