/*
SORACOM API

SORACOM API v1

API version: VERSION_PLACEHOLDER
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
)


// QueryApiService QueryApi service
type QueryApiService service

type ApiSearchDevicesRequest struct {
	ctx context.Context
	ApiService *QueryApiService
	name *[]string
	group *[]string
	deviceId *[]string
	tag *[]string
	imsi *[]string
	imei *[]string
	limit *int32
	lastEvaluatedKey *string
	searchType *string
}

// 検索したい SORACOM Inventory デバイスの名前
func (r ApiSearchDevicesRequest) Name(name []string) ApiSearchDevicesRequest {
	r.name = &name
	return r
}

// 検索したいグループの名前
func (r ApiSearchDevicesRequest) Group(group []string) ApiSearchDevicesRequest {
	r.group = &group
	return r
}

// 検索したい SORACOM Inventory デバイスの ID
func (r ApiSearchDevicesRequest) DeviceId(deviceId []string) ApiSearchDevicesRequest {
	r.deviceId = &deviceId
	return r
}

// 検索したいタグの値の文字列
func (r ApiSearchDevicesRequest) Tag(tag []string) ApiSearchDevicesRequest {
	r.tag = &tag
	return r
}

// 検索したい SORACOM Inventory デバイスの bootstrap 時の IMSI
func (r ApiSearchDevicesRequest) Imsi(imsi []string) ApiSearchDevicesRequest {
	r.imsi = &imsi
	return r
}

// 検索したい SORACOM Inventory デバイスの bootstrap 時の IMEI
func (r ApiSearchDevicesRequest) Imei(imei []string) ApiSearchDevicesRequest {
	r.imei = &imei
	return r
}

// 取得する結果の上限数
func (r ApiSearchDevicesRequest) Limit(limit int32) ApiSearchDevicesRequest {
	r.limit = &limit
	return r
}

// 現ページで取得した最後の SORACOM Inventory デバイスの ID。このパラメータを指定することで次の SORACOM Inventory デバイス以降のリストを取得できる。
func (r ApiSearchDevicesRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiSearchDevicesRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}

// 検索の種別 (AND 検索もしくは OR 検索)
func (r ApiSearchDevicesRequest) SearchType(searchType string) ApiSearchDevicesRequest {
	r.searchType = &searchType
	return r
}

func (r ApiSearchDevicesRequest) Execute() ([]Device, *http.Response, error) {
	return r.ApiService.SearchDevicesExecute(r)
}

/*
SearchDevices SORACOM Inventory デバイスをクエリに応じて検索します。

SORACOM Inventory デバイスをクエリに応じて検索します。部分一致したものを返却します。この API 権限が付与された場合、すべての SORACOM Inventory デバイスに対して group も含めた検索/一覧取得を行える権限が与えられます。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchDevicesRequest
*/
func (a *QueryApiService) SearchDevices(ctx context.Context) ApiSearchDevicesRequest {
	return ApiSearchDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Device
func (a *QueryApiService) SearchDevicesExecute(r ApiSearchDevicesRequest) ([]Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryApiService.SearchDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group", parameterToString(t, "multi"))
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("deviceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("deviceId", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.imsi != nil {
		t := *r.imsi
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("imsi", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("imsi", parameterToString(t, "multi"))
		}
	}
	if r.imei != nil {
		t := *r.imei
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("imei", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("imei", parameterToString(t, "multi"))
		}
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	if r.searchType != nil {
		localVarQueryParams.Add("search_type", parameterToString(*r.searchType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSigfoxDevicesRequest struct {
	ctx context.Context
	ApiService *QueryApiService
	name *[]string
	group *[]string
	deviceId *[]string
	tag *[]string
	status *string
	registration *string
	limit *int32
	lastEvaluatedKey *string
	searchType *string
}

// 検索したい Sigfox デバイスの名前
func (r ApiSearchSigfoxDevicesRequest) Name(name []string) ApiSearchSigfoxDevicesRequest {
	r.name = &name
	return r
}

// 検索したいグループの名前
func (r ApiSearchSigfoxDevicesRequest) Group(group []string) ApiSearchSigfoxDevicesRequest {
	r.group = &group
	return r
}

// 検索したい Sigfox デバイスの ID
func (r ApiSearchSigfoxDevicesRequest) DeviceId(deviceId []string) ApiSearchSigfoxDevicesRequest {
	r.deviceId = &deviceId
	return r
}

// 検索したいタグの値の文字列
func (r ApiSearchSigfoxDevicesRequest) Tag(tag []string) ApiSearchSigfoxDevicesRequest {
	r.tag = &tag
	return r
}

// 検索したい Sigfox デバイスの状態
func (r ApiSearchSigfoxDevicesRequest) Status(status string) ApiSearchSigfoxDevicesRequest {
	r.status = &status
	return r
}

// 検索したい Sigfox デバイスの登録状態
func (r ApiSearchSigfoxDevicesRequest) Registration(registration string) ApiSearchSigfoxDevicesRequest {
	r.registration = &registration
	return r
}

// 取得する結果の上限数
func (r ApiSearchSigfoxDevicesRequest) Limit(limit int32) ApiSearchSigfoxDevicesRequest {
	r.limit = &limit
	return r
}

// 現ページで取得した最後の Sigfox デバイスの ID。このパラメータを指定することで次の Sigfox デバイス以降のリストを取得できる。
func (r ApiSearchSigfoxDevicesRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiSearchSigfoxDevicesRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}

// 検索の種別 (AND 検索もしくは OR 検索)
func (r ApiSearchSigfoxDevicesRequest) SearchType(searchType string) ApiSearchSigfoxDevicesRequest {
	r.searchType = &searchType
	return r
}

func (r ApiSearchSigfoxDevicesRequest) Execute() ([]SigfoxDevice, *http.Response, error) {
	return r.ApiService.SearchSigfoxDevicesExecute(r)
}

/*
SearchSigfoxDevices Sigfox デバイスをクエリに応じて検索します。

Sigfox デバイスをクエリに応じて検索します。部分一致したものを返却します。この API 権限が付与された場合、すべての Sigfox デバイスに対して group も含めた検索/一覧取得を行える権限が与えられます。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchSigfoxDevicesRequest
*/
func (a *QueryApiService) SearchSigfoxDevices(ctx context.Context) ApiSearchSigfoxDevicesRequest {
	return ApiSearchSigfoxDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SigfoxDevice
func (a *QueryApiService) SearchSigfoxDevicesExecute(r ApiSearchSigfoxDevicesRequest) ([]SigfoxDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SigfoxDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryApiService.SearchSigfoxDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/sigfox_devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group", parameterToString(t, "multi"))
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("deviceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("deviceId", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.registration != nil {
		localVarQueryParams.Add("registration", parameterToString(*r.registration, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	if r.searchType != nil {
		localVarQueryParams.Add("search_type", parameterToString(*r.searchType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSimsRequest struct {
	ctx context.Context
	ApiService *QueryApiService
	name *[]string
	group *[]string
	simId *[]string
	imsi *[]string
	msisdn *[]string
	iccid *[]string
	serialNumber *[]string
	tag *[]string
	bundles *[]string
	sessionStatus *string
	limit *int32
	lastEvaluatedKey *string
	searchType *string
}

// 検索したい SIM の名前
func (r ApiSearchSimsRequest) Name(name []string) ApiSearchSimsRequest {
	r.name = &name
	return r
}

// 検索したいグループの名前
func (r ApiSearchSimsRequest) Group(group []string) ApiSearchSimsRequest {
	r.group = &group
	return r
}

// 検索したい SIM ID
func (r ApiSearchSimsRequest) SimId(simId []string) ApiSearchSimsRequest {
	r.simId = &simId
	return r
}

// 検索したい IMSI
func (r ApiSearchSimsRequest) Imsi(imsi []string) ApiSearchSimsRequest {
	r.imsi = &imsi
	return r
}

// 検索したい MSISDN
func (r ApiSearchSimsRequest) Msisdn(msisdn []string) ApiSearchSimsRequest {
	r.msisdn = &msisdn
	return r
}

// 検索したい ICCID
func (r ApiSearchSimsRequest) Iccid(iccid []string) ApiSearchSimsRequest {
	r.iccid = &iccid
	return r
}

// 検索したい製造番号
func (r ApiSearchSimsRequest) SerialNumber(serialNumber []string) ApiSearchSimsRequest {
	r.serialNumber = &serialNumber
	return r
}

// 検索したいタグの値の文字列
func (r ApiSearchSimsRequest) Tag(tag []string) ApiSearchSimsRequest {
	r.tag = &tag
	return r
}

// 検索したいバンドルタイプ
func (r ApiSearchSimsRequest) Bundles(bundles []string) ApiSearchSimsRequest {
	r.bundles = &bundles
	return r
}

// 検索したいセッションステータス (ONLINE もしくは OFFLINE)
func (r ApiSearchSimsRequest) SessionStatus(sessionStatus string) ApiSearchSimsRequest {
	r.sessionStatus = &sessionStatus
	return r
}

// 取得する結果の上限数
func (r ApiSearchSimsRequest) Limit(limit int32) ApiSearchSimsRequest {
	r.limit = &limit
	return r
}

// 現ページで取得した最後の SIM の SIM ID。このパラメータを指定することで次の SIM 以降のリストを取得できる。
func (r ApiSearchSimsRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiSearchSimsRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}

// 検索の種別 (AND 検索もしくは OR 検索)
func (r ApiSearchSimsRequest) SearchType(searchType string) ApiSearchSimsRequest {
	r.searchType = &searchType
	return r
}

func (r ApiSearchSimsRequest) Execute() ([]Sim, *http.Response, error) {
	return r.ApiService.SearchSimsExecute(r)
}

/*
SearchSims SIM をクエリに応じて検索します。

SIM をクエリに応じて検索します。部分一致したものを返却します。この API 権限が付与された場合、すべての SIM に対して group も含めた検索/一覧取得を行える権限が与えられます。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchSimsRequest
*/
func (a *QueryApiService) SearchSims(ctx context.Context) ApiSearchSimsRequest {
	return ApiSearchSimsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Sim
func (a *QueryApiService) SearchSimsExecute(r ApiSearchSimsRequest) ([]Sim, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Sim
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryApiService.SearchSims")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/sims"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group", parameterToString(t, "multi"))
		}
	}
	if r.simId != nil {
		t := *r.simId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sim_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sim_id", parameterToString(t, "multi"))
		}
	}
	if r.imsi != nil {
		t := *r.imsi
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("imsi", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("imsi", parameterToString(t, "multi"))
		}
	}
	if r.msisdn != nil {
		t := *r.msisdn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("msisdn", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("msisdn", parameterToString(t, "multi"))
		}
	}
	if r.iccid != nil {
		t := *r.iccid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("iccid", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("iccid", parameterToString(t, "multi"))
		}
	}
	if r.serialNumber != nil {
		t := *r.serialNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("serial_number", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("serial_number", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.bundles != nil {
		t := *r.bundles
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("bundles", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("bundles", parameterToString(t, "multi"))
		}
	}
	if r.sessionStatus != nil {
		localVarQueryParams.Add("session_status", parameterToString(*r.sessionStatus, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	if r.searchType != nil {
		localVarQueryParams.Add("search_type", parameterToString(*r.searchType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSubscriberTrafficVolumeRankingRequest struct {
	ctx context.Context
	ApiService *QueryApiService
	from *int64
	to *int64
	limit *int32
	order *string
}

// 検索期間の始点 (UNIX 時間 (ミリ秒))
func (r ApiSearchSubscriberTrafficVolumeRankingRequest) From(from int64) ApiSearchSubscriberTrafficVolumeRankingRequest {
	r.from = &from
	return r
}

// 検索期間の終点 (UNIX 時間 (ミリ秒))
func (r ApiSearchSubscriberTrafficVolumeRankingRequest) To(to int64) ApiSearchSubscriberTrafficVolumeRankingRequest {
	r.to = &to
	return r
}

// 取得する結果の上限数
func (r ApiSearchSubscriberTrafficVolumeRankingRequest) Limit(limit int32) ApiSearchSubscriberTrafficVolumeRankingRequest {
	r.limit = &limit
	return r
}

// ランキングの順序
func (r ApiSearchSubscriberTrafficVolumeRankingRequest) Order(order string) ApiSearchSubscriberTrafficVolumeRankingRequest {
	r.order = &order
	return r
}

func (r ApiSearchSubscriberTrafficVolumeRankingRequest) Execute() ([]TrafficVolumeRanking, *http.Response, error) {
	return r.ApiService.SearchSubscriberTrafficVolumeRankingExecute(r)
}

/*
SearchSubscriberTrafficVolumeRanking Subscriber の通信量ランキングを返却します。

指定された期間の Subscriber の通信量ランキングを検索して返却します。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchSubscriberTrafficVolumeRankingRequest
*/
func (a *QueryApiService) SearchSubscriberTrafficVolumeRanking(ctx context.Context) ApiSearchSubscriberTrafficVolumeRankingRequest {
	return ApiSearchSubscriberTrafficVolumeRankingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TrafficVolumeRanking
func (a *QueryApiService) SearchSubscriberTrafficVolumeRankingExecute(r ApiSearchSubscriberTrafficVolumeRankingRequest) ([]TrafficVolumeRanking, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TrafficVolumeRanking
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryApiService.SearchSubscriberTrafficVolumeRanking")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/subscribers/traffic_volume/ranking"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	localVarQueryParams.Add("from", parameterToString(*r.from, ""))
	localVarQueryParams.Add("to", parameterToString(*r.to, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSubscribersRequest struct {
	ctx context.Context
	ApiService *QueryApiService
	name *[]string
	group *[]string
	imsi *[]string
	msisdn *[]string
	iccid *[]string
	serialNumber *[]string
	tag *[]string
	subscription *[]string
	moduleType *[]string
	limit *int32
	lastEvaluatedKey *string
	searchType *string
}

// 検索したい Subscriber の名前
func (r ApiSearchSubscribersRequest) Name(name []string) ApiSearchSubscribersRequest {
	r.name = &name
	return r
}

// 検索したいグループの名前
func (r ApiSearchSubscribersRequest) Group(group []string) ApiSearchSubscribersRequest {
	r.group = &group
	return r
}

// 検索したい IMSI
func (r ApiSearchSubscribersRequest) Imsi(imsi []string) ApiSearchSubscribersRequest {
	r.imsi = &imsi
	return r
}

// 検索したい MSISDN
func (r ApiSearchSubscribersRequest) Msisdn(msisdn []string) ApiSearchSubscribersRequest {
	r.msisdn = &msisdn
	return r
}

// 検索したい ICCID
func (r ApiSearchSubscribersRequest) Iccid(iccid []string) ApiSearchSubscribersRequest {
	r.iccid = &iccid
	return r
}

// 検索したい製造番号
func (r ApiSearchSubscribersRequest) SerialNumber(serialNumber []string) ApiSearchSubscribersRequest {
	r.serialNumber = &serialNumber
	return r
}

// 検索したいタグの値の文字列
func (r ApiSearchSubscribersRequest) Tag(tag []string) ApiSearchSubscribersRequest {
	r.tag = &tag
	return r
}

// 検索したいサブスクリプション (例: &#x60;plan01s&#x60;)
func (r ApiSearchSubscribersRequest) Subscription(subscription []string) ApiSearchSubscribersRequest {
	r.subscription = &subscription
	return r
}

// 検索したいモジュールタイプ (例: &#x60;mini&#x60;, &#x60;virtual&#x60;)
func (r ApiSearchSubscribersRequest) ModuleType(moduleType []string) ApiSearchSubscribersRequest {
	r.moduleType = &moduleType
	return r
}

// 取得する結果の上限数
func (r ApiSearchSubscribersRequest) Limit(limit int32) ApiSearchSubscribersRequest {
	r.limit = &limit
	return r
}

// 現ページで取得した最後の Subscriber の IMSI。このパラメータを指定することで次の Subscriber 以降のリストを取得できる。
func (r ApiSearchSubscribersRequest) LastEvaluatedKey(lastEvaluatedKey string) ApiSearchSubscribersRequest {
	r.lastEvaluatedKey = &lastEvaluatedKey
	return r
}

// 検索の種別 (AND 検索もしくは OR 検索)
func (r ApiSearchSubscribersRequest) SearchType(searchType string) ApiSearchSubscribersRequest {
	r.searchType = &searchType
	return r
}

func (r ApiSearchSubscribersRequest) Execute() ([]Subscriber, *http.Response, error) {
	return r.ApiService.SearchSubscribersExecute(r)
}

/*
SearchSubscribers (非推奨) Subscriber をクエリに応じて検索します。

(非推奨の API です。代わりに `/query/sims` API を利用することを検討してください) Subscriber をクエリに応じて検索します。部分一致したものを返却します。この API 権限が付与された場合、すべての SIM に対して group も含めた検索/一覧取得を行える権限が与えられます。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchSubscribersRequest

Deprecated
*/
func (a *QueryApiService) SearchSubscribers(ctx context.Context) ApiSearchSubscribersRequest {
	return ApiSearchSubscribersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Subscriber
// Deprecated
func (a *QueryApiService) SearchSubscribersExecute(r ApiSearchSubscribersRequest) ([]Subscriber, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Subscriber
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryApiService.SearchSubscribers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/subscribers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group", parameterToString(t, "multi"))
		}
	}
	if r.imsi != nil {
		t := *r.imsi
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("imsi", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("imsi", parameterToString(t, "multi"))
		}
	}
	if r.msisdn != nil {
		t := *r.msisdn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("msisdn", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("msisdn", parameterToString(t, "multi"))
		}
	}
	if r.iccid != nil {
		t := *r.iccid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("iccid", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("iccid", parameterToString(t, "multi"))
		}
	}
	if r.serialNumber != nil {
		t := *r.serialNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("serial_number", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("serial_number", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.subscription != nil {
		t := *r.subscription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("subscription", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("subscription", parameterToString(t, "multi"))
		}
	}
	if r.moduleType != nil {
		t := *r.moduleType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("module_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("module_type", parameterToString(t, "multi"))
		}
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lastEvaluatedKey != nil {
		localVarQueryParams.Add("last_evaluated_key", parameterToString(*r.lastEvaluatedKey, ""))
	}
	if r.searchType != nil {
		localVarQueryParams.Add("search_type", parameterToString(*r.searchType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Soracom-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
